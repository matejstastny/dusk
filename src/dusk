#!/usr/bin/env bash

set -euo pipefail

# --------------------------------------------------------------------------------------------
# dusk - a diskutil list wrapper with pretty output
# --------------------------------------------------------------------------------------------
# Author: Matej Stastny
# Date: 09-02-2025 MDY
# License: MIT license
# --------------------------------------------------------------------------------------------

VERSION="dusk version 0.1.0 (dev)"

PURPLE="\033[0;35m"
RED="\033[31m"
BLUE="\033[34m"
GREEN="\033[32m"
WHITE="\033[37m"
BOLD="\033[1m"
RESET="\033[0m"

# Dependencies ------------------------------------------------------------------------------

if [[ "$(uname)" != "Darwin" ]]; then
    echo -e "${RED}Error: This script works only on macOS!${RESET}" >&2
    exit 1
fi

if ! command -v diskutil >/dev/null 2>&1; then
    echo -e "${RED}Error: diskutil command not found. This script requires diskutil.${RESET}" >&2
    exit 1
fi

# Helpers ------------------------------------------------------------------------------------

print_line() {
    local left=$1 mid=$2 right=$3
    printf "${BLUE}%s" "$left"
    for col in {0..4}; do
        printf '─%.0s' $(seq 1 $((widths[$col] + 2)))
        if [[ $col -lt 4 ]]; then
            printf "%s" "$mid"
        fi
    done
    printf "%s${RESET}\n" "$right"
}

print_row() {
    local arrname=$1
    eval "arr=(\"\${$arrname[@]}\")"
    printf "${BLUE}│${RESET}"
    for col in {0..4}; do
        local field="${arr[$col]}"
        field="$(echo "$field" | sed 's/\x1b\[[0-9;]*m//g')"
        if [[ "${arr[0]}" == "#" || $col -eq 0 ]]; then
            printf " ${GREEN}%-${widths[$col]}s${RESET}${BLUE} │${RESET}" "$field"
        else
            if [[ $col -eq 1 ]]; then
                printf " \033[3m${PURPLE}%-${widths[$col]}s${RESET}${BLUE} │${RESET}" "$field"
            else
                printf " ${WHITE}%-${widths[$col]}s${RESET}${BLUE} │${RESET}" "$field"
            fi
        fi
    done
    echo
}

# --------------------------------------------------------------------------------------------
# Flags --------------------------------------------------------------------------------------

# @getoptions
parser_definition() {
    setup REST help:usage -- "Usage: dusk [options]..." ''
    msg -- 'Options:'
    flag only_external -e --external -- "List only external disks"
    disp :usage -h --help -- "Display this amazing help message"
    disp VERSION -v --version
}
# @end

# [parser code]
# @gengetoptions parser -i parser_definition parse
# Generated by getoptions (BEGIN)
# URL: https://github.com/ko1nksm/getoptions (v3.3.2)
only_external=''
REST=''
parse() {
    OPTIND=$(($# + 1))
    while OPTARG= && [ "${REST}" != x ] && [ $# -gt 0 ]; do
        case $1 in
        --?*=*)
            OPTARG=$1
            shift
            eval 'set -- "${OPTARG%%\=*}" "${OPTARG#*\=}"' ${1+'"$@"'}
            ;;
        --no-* | --without-*) unset OPTARG ;;
        -[ehv]?*)
            OPTARG=$1
            shift
            eval 'set -- "${OPTARG%"${OPTARG#??}"}" -"${OPTARG#??}"' ${1+'"$@"'}
            case $2 in --*) set -- "$1" unknown "$2" && REST=x ;; esac
            OPTARG=
            ;;
        esac
        case $1 in
        '-e' | '--external')
            [ "${OPTARG:-}" ] && OPTARG=${OPTARG#*\=} && set "noarg" "$1" && break
            eval '[ ${OPTARG+x} ] &&:' && OPTARG='1' || OPTARG=''
            only_external="$OPTARG"
            ;;
        '-h' | '--help')
            usage
            exit 0
            ;;
        '-v' | '--version')
            echo "${VERSION}"
            exit 0
            ;;
        --)
            shift
            while [ $# -gt 0 ]; do
                REST="${REST} \"\${$(($OPTIND - $#))}\""
                shift
            done
            break
            ;;
        [-]?*)
            set "unknown" "$1"
            break
            ;;
        *)
            REST="${REST} \"\${$(($OPTIND - $#))}\""
            ;;
        esac
        shift
    done
    [ $# -eq 0 ] && {
        OPTIND=1
        unset OPTARG
        return 0
    }
    case $1 in
    unknown) set "Unrecognized option: $2" "$@" ;;
    noarg) set "Does not allow an argument: $2" "$@" ;;
    required) set "Requires an argument: $2" "$@" ;;
    pattern:*) set "Does not match the pattern (${1#*:}): $2" "$@" ;;
    notcmd) set "Not a command: $2" "$@" ;;
    *) set "Validation error ($1): $2" "$@" ;;
    esac
    echo "$1" >&2
    exit 1
}
usage() {
    cat <<'GETOPTIONSHERE'
Usage: dusk [options]...

Options:
  -e, --external              List only external disks
  -h, --help                  Display this amazing help message
  -v, --version
GETOPTIONSHERE
}
# Generated by getoptions (END)
# @end
# [/]

parse "$@"
eval "set -- $REST"
printf '%s\n' "$@"

[[ -z "$only_external" ]] && only_external=0

# Grab disk data -----------------------------------------------------------------------------

disks=$(diskutil list)

if [[ -z "$disks" ]]; then
    echo -e "${RED} ⚠️ diskutil list didn't return anything!${RESET}"
    exit 1
fi

rows=()
i=1

while IFS= read -r line; do
    [[ ! $line =~ ^/dev/disk ]] && continue

    ident=$(echo "$line" | awk '{print $1}')
    [[ $only_external -eq 1 && -z $(diskutil info "$ident" | grep External) ]] && continue
    type=$(echo "$line" | awk -F '[()]' '{print $2}')
    size=$(diskutil info "$ident" | awk -F': *' '/Disk Size/ {print $2; exit}' | awk -F' \\(' '{print $1}')
    [[ -z "$size" ]] && size="-"
    mount=$(diskutil info "$ident" | awk -F': *' '/Mount Point/ {print $2; exit}')
    [[ -z "$mount" ]] && mount="-"

    rows+=("$i|$ident|$size|$type|$mount")
    ((i++))
done <<<"$disks"

# Calculate table ----------------------------------------------------------------------------

headers=("#" "Identifier" "Size" "Type" "Mount")

widths=()
for col in $(seq 0 4); do
    max=${#headers[$col]}
    for row in "${rows[@]}"; do
        field=$(echo "$row" | cut -d'|' -f$((col + 1)))
        ((${#field} > max)) && max=${#field}
    done
    widths[$col]=$max
done

# Print table --------------------------------------------------------------------------------

print_line "╭" "┬" "╮"
printf "${BOLD}"
print_row headers
printf "${RESET}"
print_line "├" "┼" "┤"
for row in "${rows[@]}"; do
    IFS="|" read -r f1 f2 f3 f4 f5 <<<"$row"
    fields=("$f1" "$f2" "$f3" "$f4" "$f5")
    print_row fields
done
print_line "╰" "┴" "╯"
